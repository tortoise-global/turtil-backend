name: Deploy Turtil Backend - Simplified

on:
  push:
    branches: [dev, main]
    paths-ignore: ['**.md', 'docs/**']
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: ap-south-1
  TERRAFORM_VERSION: 1.12.2

jobs:
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    environment: dev
    timeout-minutes: 30
    
    steps:
      # ============================================================================
      # SETUP PHASE
      # ============================================================================
      
      - name: ðŸ“¦ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: âš™ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ============================================================================
      # PRE-DEPLOYMENT VALIDATION
      # ============================================================================
      
      - name: âœ… Validate Prerequisites
        run: |
          echo "ðŸ” Validating AWS credentials and prerequisites..."
          
          # Test AWS credentials
          aws sts get-caller-identity || {
            echo "âŒ AWS credentials invalid"
            exit 1
          }
          
          # Check if Route53 hosted zone exists
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query 'HostedZones[?Name==`turtil.co.`].Id' --output text | sed 's|/hostedzone/||')
          if [ -z "$HOSTED_ZONE_ID" ] || [ "$HOSTED_ZONE_ID" = "None" ]; then
            echo "âŒ Route53 hosted zone for turtil.co not found"
            exit 1
          fi
          echo "âœ… Route53 hosted zone found: $HOSTED_ZONE_ID"
          
          # Validate custom AMI exists
          aws ec2 describe-images --image-ids ${{ secrets.CUSTOM_AMI_ID }} --region ${{ env.AWS_REGION }} || {
            echo "âŒ Custom AMI ${{ secrets.CUSTOM_AMI_ID }} not found"
            exit 1
          }
          echo "âœ… Custom AMI validated"
          
          echo "âœ… All prerequisites validated"

      # ============================================================================
      # INFRASTRUCTURE DEPLOYMENT
      # ============================================================================
      
      - name: ðŸ—ï¸ Deploy Infrastructure
        working-directory: ./terraform
        shell: bash
        env:
          # Project Configuration
          TF_VAR_app_project_name: ${{ secrets.PROJECT_NAME }}
          TF_VAR_app_version: ${{ secrets.VERSION }}
          TF_VAR_app_environment: dev
          TF_VAR_app_debug: ${{ secrets.DEBUG }}
          TF_VAR_app_log_level: ${{ secrets.LOG_LEVEL }}
          
          # Security & Authentication
          TF_VAR_app_secret_key: ${{ secrets.SECRET_KEY }}
          TF_VAR_app_algorithm: ${{ secrets.ALGORITHM }}
          TF_VAR_app_access_token_expire_minutes: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}
          TF_VAR_app_refresh_token_expire_minutes: ${{ secrets.REFRESH_TOKEN_EXPIRE_MINUTES }}
          
          # OTP Configuration
          TF_VAR_app_otp_expiry_minutes: ${{ secrets.OTP_EXPIRY_MINUTES }}
          TF_VAR_app_otp_max_attempts: ${{ secrets.OTP_MAX_ATTEMPTS }}
          TF_VAR_app_dev_otp: ${{ secrets.DEV_OTP }}
          
          # Application Settings
          TF_VAR_app_cors_origins: ${{ secrets.CORS_ORIGINS }}
          TF_VAR_app_allowed_hosts: ${{ secrets.ALLOWED_HOSTS }}
          TF_VAR_app_rate_limit_calls: ${{ secrets.RATE_LIMIT_CALLS }}
          TF_VAR_app_rate_limit_period: ${{ secrets.RATE_LIMIT_PERIOD }}
          
          # Database & Cache
          TF_VAR_app_db_username: ${{ secrets.DB_USERNAME }}
          TF_VAR_app_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_app_database_url: ${{ secrets.DATABASE_URL }}
          TF_VAR_app_upstash_redis_url: ${{ secrets.UPSTASH_REDIS_URL }}
          TF_VAR_app_upstash_redis_token: ${{ secrets.UPSTASH_REDIS_TOKEN }}
          TF_VAR_app_redis_user_cache_ttl: ${{ secrets.REDIS_USER_CACHE_TTL }}
          TF_VAR_app_redis_blacklist_ttl: ${{ secrets.REDIS_BLACKLIST_TTL }}
          
          # AWS Services
          TF_VAR_app_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_app_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_app_aws_region: ${{ secrets.AWS_REGION }}
          TF_VAR_app_aws_ses_from_email: ${{ secrets.AWS_SES_FROM_EMAIL }}
          TF_VAR_app_aws_ses_region: ${{ secrets.AWS_SES_REGION }}
          TF_VAR_ecr_account_id: ${{ secrets.ECR_ACCOUNT_ID }}
          TF_VAR_app_s3_bucket_name: ${{ secrets.S3_BUCKET_NAME }}
          TF_VAR_custom_ami_id: ${{ secrets.CUSTOM_AMI_ID }}
          
          # Legacy compatibility
          TF_VAR_project_name: ${{ secrets.PROJECT_NAME }}
        run: |
          set +e  # Disable exit on error temporarily for terraform plan
          
          echo "ðŸ”§ Initializing Terraform..."
          terraform init -upgrade
          
          echo "ðŸ“‹ Creating Terraform plan..."
          terraform plan -out=tfplan -detailed-exitcode
          PLAN_EXIT_STATUS=$?
          
          set -e  # Re-enable exit on error
          
          if [ $PLAN_EXIT_STATUS -eq 0 ]; then
            echo "âœ… No infrastructure changes needed"
            if [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
              echo "â­ï¸ Skipping infrastructure deployment"
            else
              echo "ðŸ”„ Force deployment requested"
              terraform apply -auto-approve tfplan
            fi
          elif [ $PLAN_EXIT_STATUS -eq 2 ]; then
            echo "ðŸ”„ Infrastructure changes detected, applying..."
            terraform apply -auto-approve tfplan
          else
            echo "âŒ Terraform plan failed with exit code $PLAN_EXIT_STATUS"
            exit 1
          fi
          
          echo "âœ… Infrastructure deployment completed"

      # ============================================================================
      # DOCKER BUILD AND PUSH
      # ============================================================================
      
      - name: ðŸ³ Build and Push Docker Image
        run: |
          echo "ðŸ”‘ Logging into ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ secrets.ECR_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          ECR_REPO_NAME="${{ secrets.PROJECT_NAME }}-dev"
          ECR_REGISTRY="${{ secrets.ECR_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          echo "ðŸ—ï¸ Building Docker image for ARM64 using buildx..."
          docker buildx build \
            --platform linux/arm64 \
            --tag $ECR_REGISTRY/$ECR_REPO_NAME:latest \
            --tag $ECR_REGISTRY/$ECR_REPO_NAME:dev \
            --tag $ECR_REGISTRY/$ECR_REPO_NAME:${{ github.sha }} \
            --push \
            .
          
          echo "âœ… Docker build and push completed"

      # ============================================================================
      # DEPLOYMENT VERIFICATION
      # ============================================================================
      
      - name: â³ Wait for Instance Startup
        working-directory: ./terraform
        run: |
          echo "â³ Waiting for EC2 instance to be ready..."
          
          INSTANCE_ID=$(terraform output -raw ec2_instance_id)
          
          # Wait for instance to be running
          echo "ðŸ”„ Waiting for instance $INSTANCE_ID to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
          
          # Wait for status checks to pass
          echo "ðŸ”„ Waiting for instance status checks to pass..."
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
          
          echo "âœ… EC2 instance is ready"

      - name: âš¡ Restart Application Service
        working-directory: ./terraform
        continue-on-error: true  # Don't fail deployment if restart fails
        run: |
          echo "ðŸ”„ Restarting application on EC2 instance..."
          
          INSTANCE_ID=$(terraform output -raw ec2_instance_id)
          
          # Send restart command to EC2 instance
          echo "ðŸ“¤ Sending restart command to instance $INSTANCE_ID..."
          ECR_URI="${{ secrets.ECR_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ secrets.PROJECT_NAME }}-dev:latest"
          
          if aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com\",\"sudo docker pull $ECR_URI\",\"sudo systemctl restart turtil-backend\",\"sleep 10\",\"sudo systemctl status turtil-backend --no-pager\"]" \
            --region ${{ env.AWS_REGION }} \
            --output json > /tmp/restart_command.json; then
            
            # Get command ID and wait for completion
            COMMAND_ID=$(cat /tmp/restart_command.json | jq -r '.Command.CommandId')
            
            echo "â³ Waiting for restart command to complete (Command ID: $COMMAND_ID)..."
            if aws ssm wait command-executed \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} \
              --cli-read-timeout 300; then
              echo "âœ… Application restart completed successfully"
            else
              echo "âš ï¸ Restart command timed out, but continuing with health checks"
            fi
          else
            echo "âš ï¸ Failed to send SSM command, will rely on user data script for deployment"
          fi

      - name: ðŸ¥ Comprehensive Health Checks
        working-directory: ./terraform
        timeout-minutes: 10
        run: |
          echo "ðŸ¥ Starting comprehensive health checks..."
          
          # Get deployment details
          API_URL=$(terraform output -raw dev_api_url)
          INSTANCE_IP=$(terraform output -raw ec2_public_ip)
          HEALTH_ENDPOINT="${API_URL}/health"
          DOCS_ENDPOINT="${API_URL}/docs"
          DIRECT_HEALTH="http://$INSTANCE_IP:8000/health"
          
          echo "ðŸ“Š Deployment Details:"
          echo "   API URL: $API_URL"
          echo "   Instance IP: $INSTANCE_IP"
          echo "   Health Check: $HEALTH_ENDPOINT"
          echo "   Documentation: $DOCS_ENDPOINT"
          
          # Function to test endpoint with retries
          test_endpoint() {
            local url="$1"
            local name="$2"
            local max_attempts=10
            local delay=15
            
            echo "ðŸ” Testing $name: $url"
            
            for i in $(seq 1 $max_attempts); do
              if curl -f -s --max-time 10 "$url" > /dev/null; then
                echo "âœ… $name is healthy (attempt $i/$max_attempts)"
                return 0
              else
                echo "â³ $name not ready yet (attempt $i/$max_attempts)"
                if [ $i -lt $max_attempts ]; then
                  sleep $delay
                fi
              fi
            done
            
            echo "âŒ $name failed after $max_attempts attempts"
            return 1
          }
          
          # Wait for application startup
          echo "â³ Waiting for application startup (60 seconds)..."
          sleep 60
          
          # Test direct IP access first
          if test_endpoint "$DIRECT_HEALTH" "Direct IP Health Check"; then
            echo "âœ… Direct IP access working"
          else
            echo "âŒ Direct IP access failed - application may not be running"
            exit 1
          fi
          
          # Test domain access
          if test_endpoint "$HEALTH_ENDPOINT" "Domain Health Check"; then
            echo "âœ… Domain access working"
          else
            echo "âš ï¸ Domain access failed - DNS may not be propagated yet"
            echo "ðŸ” Checking DNS resolution..."
            nslookup dev.api.turtil.co || echo "DNS resolution failed"
            echo "ðŸ’¡ Try direct IP access: $DIRECT_HEALTH"
          fi
          
          # Test API documentation
          if curl -f -s --max-time 10 "$DOCS_ENDPOINT" > /dev/null; then
            echo "âœ… API documentation accessible"
          else
            echo "âš ï¸ API documentation not accessible"
          fi
          
          echo "ðŸŽ‰ Health checks completed"

      # ============================================================================
      # DEPLOYMENT SUMMARY
      # ============================================================================
      
      - name: ðŸ“Š Deployment Summary
        if: always()
        working-directory: ./terraform
        run: |
          echo "========================================"
          echo "ðŸš€ DEPLOYMENT SUMMARY"
          echo "========================================"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Timestamp: $(date -u)"
          echo ""
          
          # Infrastructure details
          echo "ðŸ—ï¸ Infrastructure:"
          echo "   Region: ${{ env.AWS_REGION }}"
          echo "   Instance ID: $(terraform output -raw ec2_instance_id)"
          echo "   Instance IP: $(terraform output -raw ec2_public_ip)"
          echo "   Database: $(terraform output -raw database_endpoint)"
          echo "   S3 Bucket: $(terraform output -raw s3_bucket_name)"
          echo ""
          
          # Application URLs
          echo "ðŸŒ Application URLs:"
          echo "   API: $(terraform output -raw dev_api_url)"
          echo "   Health: $(terraform output -raw dev_api_url)/health"
          echo "   Docs: $(terraform output -raw dev_api_url)/docs"
          echo "   Direct: http://$(terraform output -raw ec2_public_ip):8000"
          echo ""
          
          # Deployment status
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… Deployment Status: SUCCESS"
          else
            echo "âŒ Deployment Status: FAILED"
          fi
          echo "========================================"

      # ============================================================================
      # CLEANUP AND NOTIFICATIONS
      # ============================================================================
      
      - name: ðŸ§¹ Cleanup on Failure
        if: failure()
        working-directory: ./terraform
        run: |
          echo "ðŸ§¹ Performing cleanup after deployment failure..."
          
          # Get instance details for troubleshooting
          INSTANCE_ID=$(terraform output -raw ec2_instance_id 2>/dev/null || echo "unknown")
          
          if [ "$INSTANCE_ID" != "unknown" ]; then
            echo "ðŸ” Instance $INSTANCE_ID logs:"
            aws logs get-log-events \
              --log-group-name "/aws/ec2/turtil-backend" \
              --log-stream-name "$INSTANCE_ID" \
              --limit 50 \
              --region ${{ env.AWS_REGION }} \
              --output text 2>/dev/null || echo "No logs available"
          fi
          
          echo "ðŸŽ¯ Troubleshooting tips:"
          echo "1. Check EC2 instance status in AWS console"
          echo "2. SSH into instance and check Docker logs: sudo docker logs turtil-backend"
          echo "3. Check nginx logs: sudo tail -f /var/log/nginx/error.log"
          echo "4. Verify environment variables are set correctly"